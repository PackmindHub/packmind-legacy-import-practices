import { readFileSync, writeFileSync, existsSync, readdirSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join, resolve, basename } from 'path';
import { createInterface } from 'readline';
import type { ParsedPractice, DetectionUnitTest, Example, Guidelines, Toolings, SimilarityFeatures } from './types.js';
import { displayPracticeStats, displayPracticeList, displayCategoryStats } from './OutputAnalysis.js';
import { YamlExporter } from './YamlExporter.js';
import { YamlMinifier } from './YamlMinifier.js';
import { CategoryMapper } from './CategoryMapper.js';
import { PackmindAPI } from './PackmindAPI.js';
import { PracticeToStandardConvertor } from './PracticeToStandardConvertor.js';
import { stringToProgrammingLanguage } from './ProgrammingLanguage.js';
import { PackmindV3Connector } from './PackmindV3Connector.js';
import { validateLLMConfiguration } from './LLMService.js';
import type { ValidationOutput } from './types.js';

// Bun automatically loads .env files

// ============================================================================
// Path Utilities (handles Bun compiled binaries)
// ============================================================================

/**
 * Gets the project root directory.
 * When running as a Bun compiled binary, import.meta.url points to a virtual
 * filesystem (/$bunfs/...), so we need to use process.cwd() instead.
 */
function getProjectRoot(): string {
  const metaUrl = import.meta.url;
  
  // Check if we're running in a Bun compiled binary (virtual filesystem)
  if (metaUrl.includes('/$bunfs/') || metaUrl.includes('$bunfs')) {
    // Use current working directory for compiled binaries
    return process.cwd();
  }
  
  // For normal execution, use the traditional approach
  const __filename = fileURLToPath(metaUrl);
  const __dirname = dirname(__filename);
  return join(__dirname, '..');
}

/**
 * Gets the res/ directory path
 */
function getResDir(): string {
  return join(getProjectRoot(), 'res');
}

// ============================================================================
// Space Utilities
// ============================================================================

interface Space {
  _id: string;
  name: string;
}

/**
 * Converts a space name to a URL-friendly slug
 * e.g., "BforBank-Backend" -> "bforbank-backend"
 */
function slugify(name: string): string {
  return name
    .toLowerCase()
    .replace(/\s+/g, '-')     // Replace spaces with hyphens
    .replace(/[^a-z0-9-]/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/-+/g, '-')      // Collapse multiple hyphens
    .replace(/^-|-$/g, '');   // Remove leading/trailing hyphens
}

/**
 * Loads the spaces.json file and returns a Map of space ID -> space name
 */
function loadSpacesMapping(spacesJsonPath: string): Map<string, string> {
  if (!existsSync(spacesJsonPath)) {
    throw new Error(`Spaces file not found: ${spacesJsonPath}\nUse --get-spaces to fetch spaces from Packmind API first.`);
  }
  
  const content = readFileSync(spacesJsonPath, 'utf-8');
  const spaces: Space[] = JSON.parse(content);
  
  const mapping = new Map<string, string>();
  for (const space of spaces) {
    mapping.set(space._id, space.name);
  }
  
  return mapping;
}

/**
 * Discovers all .jsonl files in a directory
 */
function discoverJsonlFiles(directory: string): string[] {
  if (!existsSync(directory)) {
    return [];
  }
  
  const files = readdirSync(directory);
  return files
    .filter(file => file.endsWith('.jsonl'))
    .map(file => join(directory, file))
    .sort();
}

/**
 * Discovers all .minified.yaml files in a directory
 */
function discoverMinifiedYamlFiles(directory: string): string[] {
  if (!existsSync(directory)) {
    return [];
  }
  
  const files = readdirSync(directory);
  return files
    .filter(file => file.endsWith('.minified.yaml'))
    .map(file => join(directory, file))
    .sort();
}

/**
 * Discovers all .standards-mapping.yaml files in a directory
 */
function discoverStandardsMappingFiles(directory: string): string[] {
  if (!existsSync(directory)) {
    return [];
  }
  
  const files = readdirSync(directory);
  return files
    .filter(file => file.endsWith('.standards-mapping.yaml'))
    .map(file => join(directory, file))
    .sort();
}

/**
 * Discovers all .standards-validation.json files in a directory
 */
function discoverValidationFiles(directory: string): string[] {
  if (!existsSync(directory)) {
    return [];
  }
  
  const files = readdirSync(directory);
  return files
    .filter(file => file.endsWith('.standards-validation.json'))
    .map(file => join(directory, file))
    .sort();
}

/**
 * Stats for a validation file
 */
interface ValidationFileStats {
  path: string;
  filename: string;
  standardsCount: number;
  rulesCount: number;
}

/**
 * Stats for a mapping file generated by the --map command
 */
interface MappingFileStats {
  filename: string;
  practicesCount: number;
  standardsCount: number;
}

/**
 * Result of importing a single validation file
 */
interface ImportFileResult {
  filename: string;
  standardsImported: number;
  rulesImported: number;
  standardsFailed: number;
  rulesFailed: number;
  status: 'success' | 'partial' | 'failed';
}

/**
 * Extracts stats from a standards-mapping.yaml file
 */
function getMappingFileStats(filePath: string): MappingFileStats {
  const content = readFileSync(filePath, 'utf-8');
  // Parse YAML to count standards and practices
  // The format is: standards: [{ name, description, practices: [...] }, ...]
  const lines = content.split('\n');
  let standardsCount = 0;
  let practicesCount = 0;
  
  // Count standards by looking for "- name:" patterns at root level of standards array
  // Count practices by looking for practice items under each standard
  let inPractices = false;
  for (const line of lines) {
    // Standard entries start with "  - name:" (2 spaces + dash)
    if (/^  - name:/.test(line)) {
      standardsCount++;
      inPractices = false;
    }
    // Practices section
    if (/^\s+practices:/.test(line)) {
      inPractices = true;
    }
    // Practice items are indented list items under practices (6 spaces + dash)
    if (inPractices && /^      - /.test(line)) {
      practicesCount++;
    }
  }
  
  return {
    filename: basename(filePath),
    practicesCount,
    standardsCount,
  };
}

/**
 * Extracts stats from a validation JSON file
 */
function getValidationFileStats(filePath: string): ValidationFileStats {
  const content = JSON.parse(readFileSync(filePath, 'utf-8')) as ValidationOutput;
  let rulesCount = 0;
  for (const standard of content.standards) {
    rulesCount += standard.rules?.length || 0;
  }
  return {
    path: filePath,
    filename: basename(filePath),
    standardsCount: content.standards.length,
    rulesCount,
  };
}

/**
 * Prompts user for input via readline
 */
function promptUser(question: string): Promise<string> {
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.trim());
    });
  });
}

/**
 * Parses user selection input into array of indices
 * Accepts: empty string (all), "all", or comma-separated numbers like "1,3,5"
 * @returns Array of 0-based indices, or null for "all"
 */
function parseSelectionInput(input: string, maxIndex: number): number[] | null {
  const trimmed = input.trim().toLowerCase();
  
  // Empty input or "all" means select all
  if (trimmed === '' || trimmed === 'all') {
    return null; // null means "all"
  }
  
  // Parse comma-separated numbers
  const parts = trimmed.split(',').map(s => s.trim()).filter(s => s.length > 0);
  const indices: number[] = [];
  
  for (const part of parts) {
    const num = parseInt(part, 10);
    if (isNaN(num) || num < 1 || num > maxIndex) {
      throw new Error(`Invalid selection: "${part}". Please enter numbers between 1 and ${maxIndex}.`);
    }
    indices.push(num - 1); // Convert to 0-based index
  }
  
  if (indices.length === 0) {
    throw new Error('No valid selections provided.');
  }
  
  // Remove duplicates and sort
  return [...new Set(indices)].sort((a, b) => a - b);
}

/**
 * Displays validation files with stats and prompts user for selection
 * @returns Array of selected file stats
 */
async function promptFileSelection(allStats: ValidationFileStats[]): Promise<ValidationFileStats[]> {
  console.log('');
  console.log('='.repeat(60));
  console.log(`Discovered ${allStats.length} validation file(s) in res/:`);
  console.log('='.repeat(60));
  console.log('');
  
  // Display numbered list with stats
  for (let i = 0; i < allStats.length; i++) {
    const stats = allStats[i];
    if (!stats) continue;
    console.log(`  [${i + 1}] ${stats.filename}`);
    console.log(`      Standards: ${stats.standardsCount} | Rules: ${stats.rulesCount}`);
    console.log('');
  }
  
  // Prompt for selection
  const selectionInput = await promptUser('Select files to import (enter numbers like "1,3" or press Enter for all): ');
  
  let selectedStats: ValidationFileStats[];
  let selectionDescription: string;
  
  try {
    const indices = parseSelectionInput(selectionInput, allStats.length);
    
    if (indices === null) {
      // All selected
      selectedStats = allStats;
      selectionDescription = 'ALL';
    } else {
      selectedStats = indices.map(i => allStats[i]).filter((s): s is ValidationFileStats => s !== undefined);
      selectionDescription = indices.map(i => i + 1).join(', ');
    }
  } catch (error) {
    throw error;
  }
  
  // Calculate totals for selected files
  let totalStandards = 0;
  let totalRules = 0;
  for (const stats of selectedStats) {
    totalStandards += stats.standardsCount;
    totalRules += stats.rulesCount;
  }
  
  console.log('');
  console.log(`Selected: ${selectionDescription} (${selectedStats.length} file(s), ${totalStandards} standards, ${totalRules} rules total)`);
  
  // Confirm selection
  const confirm = await promptUser('Proceed with import? (y/n): ');
  
  if (confirm.toLowerCase() !== 'y' && confirm.toLowerCase() !== 'yes') {
    throw new Error('Import cancelled by user.');
  }
  
  return selectedStats;
}

/**
 * Extracts the space slug from a standards-mapping.yaml filename
 * e.g., "bforbank-android.standards-mapping.yaml" -> "bforbank-android"
 */
function extractSlugFromStandardsMappingFilename(filename: string): string | null {
  const match = /^(.+)\.standards-mapping\.yaml$/.exec(filename);
  return match ? match[1] ?? null : null;
}

/**
 * Extracts the space ID from practices (assumes all practices in a file belong to the same space)
 */
function extractSpaceIdFromPractices(practices: ParsedPractice[]): string | null {
  if (practices.length === 0) {
    return null;
  }
  return practices[0]?.space ?? null;
}

/**
 * Builds a reverse lookup from slug to space ID
 * e.g., "bforbank-backend" -> "668bb6e13b9a4106512f38e2"
 */
function buildSlugToSpaceIdMap(spacesMapping: Map<string, string>): Map<string, string> {
  const slugToSpaceId = new Map<string, string>();
  for (const [spaceId, spaceName] of spacesMapping) {
    const slug = slugify(spaceName);
    slugToSpaceId.set(slug, spaceId);
  }
  return slugToSpaceId;
}

// ============================================================================
// CLI Arguments Parsing
// ============================================================================

interface CliArgs {
  command: 'init' | 'stats' | 'map' | 'get-spaces' | 'import' | 'analyze';
  inputFile?: string;
  outputFile?: string;
  importOne?: boolean;
}

/**
 * Displays usage information
 */
function showUsage(): void {
  console.log(`
Usage: packmind-legacy-import [command] [options]

Commands:
  --map                                Run full pipeline: get-spaces → init → map (recommended)
  --get-spaces                         Fetch available spaces from Packmind API (manual/debug)
  --init                               Process all .jsonl files in res/ (manual/debug)
  --init <input.jsonl> [output.yaml]   Convert single JSONL file to YAML format
  --stats                              Display practice statistics (default)
  --import                             Import .standards-validation.json files to Packmind V3
  --import --one                       Import only the first standard from each file
  --analyze                            Analyze detection capabilities of practices in .jsonl files
  --help                               Show this help message

Workflow:
  1. Place .jsonl files (one per space) in the res/ folder
  2. Run --map to execute the full pipeline:
     - Fetches spaces.json from Packmind API
     - Processes .jsonl files into {space-slug}.yaml + {space-slug}.minified.yaml
     - Generates {space-slug}.standards-mapping.yaml for each space using LLM
  3. Run --import to import standards to Packmind V3:
     - Scans res/ for .standards-validation.json files
     - Shows file list with standards/rules count
     - Prompts to select files (enter numbers or press Enter for all)
     - Imports selected files to Packmind V3

  Note: --get-spaces and --init are available for manual control/debugging.

Environment Variables:
  SOURCE_PACKMIND_API_KEY              Required for --map/--get-spaces: Your Packmind API key
  PACKMIND_V3_API_KEY                  Required for --import: Your Packmind V3 API key

  LLM Provider (required for --map):
  LLM_PROVIDER                         Required: "OPENAI" or "AZURE_OPENAI"

  OpenAI Provider (when LLM_PROVIDER=OPENAI):
  OPENAI_API_KEY                       Required: Your OpenAI API key
  OPENAI_MODEL                         Optional: Model to use (default: gpt-5.1)

  Azure OpenAI Provider (when LLM_PROVIDER=AZURE_OPENAI):
  AZURE_OPENAI_API_KEY                 Required: Your Azure OpenAI API key
  AZURE_OPENAI_ENDPOINT                Required: Azure endpoint (e.g., https://my-resource.openai.azure.com)
  AZURE_OPENAI_DEPLOYMENT              Required: Deployment name
  AZURE_OPENAI_API_VERSION             Optional: API version (default: 2024-12-01-preview)

Examples:
  npx packmind-legacy-import --map                    # Run full pipeline (recommended)
  npx packmind-legacy-import --get-spaces             # Fetch spaces only (debug)
  npx packmind-legacy-import --init                   # Process .jsonl files only (debug)
  npx packmind-legacy-import --init file.jsonl        # Process single file
  npx packmind-legacy-import --stats
  npx packmind-legacy-import --import                 # Interactive import of validation files
  npx packmind-legacy-import --import --one           # Import first standard only per file
  npx packmind-legacy-import --analyze                # Analyze detection capabilities
`);
}

/**
 * Parses command line arguments
 */
function parseArgs(args: string[]): CliArgs {
  const relevantArgs = args.slice(2); // Skip node and script path

  if (relevantArgs.includes('--help') || relevantArgs.includes('-h')) {
    showUsage();
    process.exit(0);
  }

  if (relevantArgs.includes('--init')) {
    const initIndex = relevantArgs.indexOf('--init');
    const inputFile = relevantArgs[initIndex + 1];
    const outputFile = relevantArgs[initIndex + 2];

    // If no input file or next arg is another flag, use multi-file mode
    if (!inputFile || inputFile.startsWith('--')) {
      return {
        command: 'init',
        // No inputFile means process all .jsonl files in res/
      };
    }

    return {
      command: 'init',
      inputFile,
      outputFile,
    };
  }

  if (relevantArgs.includes('--map')) {
    return { command: 'map' };
  }

  if (relevantArgs.includes('--get-spaces')) {
    return { command: 'get-spaces' };
  }

  if (relevantArgs.includes('--import')) {
    // Check for --one flag
    const importOne = relevantArgs.includes('--one');

    return {
      command: 'import',
      importOne,
    };
  }

  if (relevantArgs.includes('--analyze')) {
    return { command: 'analyze' };
  }

  // Default command is stats
  return { command: 'stats' };
}

// ============================================================================
// Practice Parsing
// ============================================================================

/**
 * Parses a practice JSON string and extracts the required properties:
 * - name
 * - description
 * - categories
 * - examples
 * - suggestionsDisabled (optional)
 * - detectionUnitTests (optional)
 * - guidelines (optional)
 * - toolings (optional)
 * 
 * @param jsonString - The JSON string representing a practice object
 * @returns ParsedPractice object with the extracted properties
 * @throws Error if the JSON is invalid or required properties are missing
 */
export function parsePractice(jsonString: string): ParsedPractice {
  try {
    const parsed = JSON.parse(jsonString);
    
    // Validate that required properties exist
    if (!parsed.name) {
      throw new Error('Missing required property: name');
    }
    // Use name as fallback if description is missing
    if (!parsed.description) {
      parsed.description = parsed.name;
    }
    if (!parsed.categories) {
      throw new Error('Missing required property: categories');
    }
    if (!parsed.examples) {
      throw new Error('Missing required property: examples');
    }
    if (!parsed.space) {
      throw new Error('Missing required property: space');
    }
    
    // Extract and return the properties (guidelines, toolings, and suggestionsDisabled are optional)
    const result: ParsedPractice = {
      name: parsed.name,
      description: parsed.description,
      categories: parsed.categories as string[],
      examples: parsed.examples as Example[],
      space: parsed.space as string,
    };
    
    // Add optional properties only if present
    if (parsed.suggestionsDisabled !== undefined) {
      result.suggestionsDisabled = parsed.suggestionsDisabled as boolean;
    }
    if (parsed.detectionUnitTests) {
      result.detectionUnitTests = parsed.detectionUnitTests as DetectionUnitTest[];
    }
    if (parsed.guidelines) {
      result.guidelines = parsed.guidelines as Guidelines;
    }
    if (parsed.toolings) {
      // Validate that toolings.language is present and valid
      if (!parsed.toolings.language) {
        throw new Error(`Practice "${parsed.name}" has toolings but missing required property: toolings.language`);
      }
      // Validate that the language matches a known ProgrammingLanguage enum value
      try {
        stringToProgrammingLanguage(parsed.toolings.language);
      } catch {
        throw new Error(`Practice "${parsed.name}" has invalid toolings.language: "${parsed.toolings.language}". Must be a valid ProgrammingLanguage.`);
      }
      result.toolings = parsed.toolings as Toolings;
    }
    if (parsed.similarityFeatures) {
      result.similarityFeatures = parsed.similarityFeatures as SimilarityFeatures;
    }
    
    return result;
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error(`Invalid JSON string: ${error.message}`);
    }
    throw error;
  }
}

/**
 * Reads and parses a JSONL file into an array of practices
 */
function loadPracticesFromFile(filePath: string): ParsedPractice[] {
  const fileContent = readFileSync(filePath, 'utf-8');
  const lines = fileContent.split('\n').filter(line => line.trim().length > 0);
  
  const practices: ParsedPractice[] = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;
    
    try {
      const practice = parsePractice(line);
      practices.push(practice);
    } catch (error) {
      console.error(`Error parsing practice at line ${i + 1}:`, error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  }
  
  return practices;
}

// ============================================================================
// Commands
// ============================================================================

/**
 * Converts a single JSONL file to YAML format (legacy single-file mode)
 */
function runSingleFileInit(inputFile: string, outputFile?: string): void {
  const resolvedInput = resolve(inputFile);
  
  if (!existsSync(resolvedInput)) {
    console.error(`Error: Input file not found: ${resolvedInput}`);
    process.exit(1);
  }
  
  // Default output file: same name with .yaml extension
  const resolvedOutput = outputFile 
    ? resolve(outputFile) 
    : resolvedInput.replace(/\.jsonl?$/, '.yaml');
  
  console.log(`Converting: ${resolvedInput}`);
  console.log(`Output:     ${resolvedOutput}`);
  console.log('');
  
  const practices = loadPracticesFromFile(resolvedInput);
  
  const exporter = new YamlExporter(2); // 2 lines of context
  exporter.export(practices, resolvedOutput);
}

/**
 * Processes all .jsonl files in res/ directory, creating space-prefixed outputs
 * @throws Error if spaces.json is missing or no .jsonl files are found
 */
function runMultiFileInit(): void {
  const resDir = getResDir();
  const spacesJsonPath = join(resDir, 'spaces.json');
  
  // Load spaces mapping (throws if file not found)
  const spacesMapping = loadSpacesMapping(spacesJsonPath);
  
  // Discover all .jsonl files
  const jsonlFiles = discoverJsonlFiles(resDir);
  
  if (jsonlFiles.length === 0) {
    throw new Error('No .jsonl files found in res/ directory. Place your .jsonl files in the res/ folder and try again.');
  }
  
  console.log('='.repeat(60));
  console.log('Multi-Space Init: Processing all .jsonl files');
  console.log('='.repeat(60));
  console.log(`Found ${jsonlFiles.length} .jsonl file(s) in res/`);
  console.log('');
  
  const exporter = new YamlExporter(2);
  const minifier = new YamlMinifier();
  let processedCount = 0;
  
  for (const jsonlPath of jsonlFiles) {
    const fileName = basename(jsonlPath);
    console.log('-'.repeat(60));
    console.log(`Processing: ${fileName}`);
    console.log('-'.repeat(60));
    
    // Load practices
    const practices = loadPracticesFromFile(jsonlPath);
    
    if (practices.length === 0) {
      console.log(`  ⚠️  Skipping: No practices found in ${fileName}`);
      console.log('');
      continue;
    }
    
    // Extract space ID and get space name
    const spaceId = extractSpaceIdFromPractices(practices);
    
    if (!spaceId) {
      console.log(`  ⚠️  Skipping: No space ID found in ${fileName}`);
      console.log('');
      continue;
    }
    
    const spaceName = spacesMapping.get(spaceId);
    
    if (!spaceName) {
      console.log(`  ⚠️  Skipping: Unknown space ID "${spaceId}" in ${fileName}`);
      console.log(`      Make sure spaces.json contains this space ID.`);
      console.log('');
      continue;
    }
    
    // Generate slugged prefix
    const slug = slugify(spaceName);
    
    console.log(`  Space: ${spaceName}`);
    console.log(`  Slug:  ${slug}`);
    console.log(`  Practices: ${practices.length}`);
    
    // Generate output paths
    const yamlPath = join(resDir, `${slug}.yaml`);
    const minifiedPath = join(resDir, `${slug}.minified.yaml`);
    
    // Export to YAML
    console.log(`  → Exporting to ${slug}.yaml`);
    exporter.export(practices, yamlPath);
    
    // Create minified version
    console.log(`  → Creating ${slug}.minified.yaml`);
    minifier.processFile(yamlPath, minifiedPath);
    
    processedCount++;
    console.log('');
  }
  
  console.log('='.repeat(60));
  console.log(`Done! Processed ${processedCount} space(s).`);
  console.log('='.repeat(60));
}

/**
 * Converts JSONL file(s) to YAML format
 * - If inputFile is provided: single-file mode (legacy behavior)
 * - If no inputFile: multi-file mode (process all .jsonl in res/)
 */
function runInitCommand(inputFile?: string, outputFile?: string): void {
  if (inputFile) {
    runSingleFileInit(inputFile, outputFile);
  } else {
    runMultiFileInit();
  }
}

/**
 * Displays statistics about practices
 */
function runStatsCommand(): void {
  const jsonlPath = join(getResDir(), 'practices.jsonl');
  
  if (!existsSync(jsonlPath)) {
    console.error(`Error: Default practices file not found: ${jsonlPath}`);
    console.error('Use --init <file.jsonl> to convert a JSONL file first.');
    process.exit(1);
  }
  
  const practices = loadPracticesFromFile(jsonlPath);
  
  displayPracticeStats(practices);
  displayCategoryStats(practices);
  displayPracticeList(practices);
}

/**
 * Extracts the space slug prefix from a minified.yaml filename
 * e.g., "bforbank-backend.minified.yaml" -> "bforbank-backend"
 */
function extractSlugFromMinifiedFilename(filename: string): string | null {
  const match = /^(.+)\.minified\.yaml$/.exec(filename);
  return match ? match[1] ?? null : null;
}

/**
 * Runs only the LLM mapping step (Step 3 of the pipeline)
 * Processes all .minified.yaml files in res/ directory
 * @returns Array of stats for successfully generated mapping files
 */
async function runLLMMappingStep(): Promise<MappingFileStats[]> {
  const resDir = getResDir();
  
  // Discover all .minified.yaml files
  const minifiedFiles = discoverMinifiedYamlFiles(resDir);
  
  if (minifiedFiles.length === 0) {
    throw new Error('No .minified.yaml files found in res/ directory.');
  }
  
  console.log('='.repeat(60));
  console.log('Step 3: Generating standards mapping using LLM');
  console.log('='.repeat(60));
  console.log(`Found ${minifiedFiles.length} .minified.yaml file(s) in res/`);
  console.log('');
  
  const generatedStats: MappingFileStats[] = [];
  let errorCount = 0;
  
  for (const minifiedPath of minifiedFiles) {
    const fileName = basename(minifiedPath);
    const slug = extractSlugFromMinifiedFilename(fileName);
    
    if (!slug) {
      console.log(`⚠️  Skipping: Could not extract slug from ${fileName}`);
      continue;
    }
    
    console.log('='.repeat(60));
    console.log(`Processing: ${fileName}`);
    console.log(`Space slug: ${slug}`);
    console.log('='.repeat(60));
    console.log('');
    
    // Generate output paths based on slug
    const yamlPath = join(resDir, `${slug}.yaml`);
    const outputMappingPath = join(resDir, `${slug}.standards-mapping.yaml`);
    
    // Check that the corresponding .yaml file exists
    if (!existsSync(yamlPath)) {
      console.log(`⚠️  Skipping: ${slug}.yaml not found (required for mapping)`);
      console.log('');
      continue;
    }
    
    const mapper = new CategoryMapper({
      inputYamlPath: yamlPath,
      minifiedYamlPath: minifiedPath,
      outputMappingPath: outputMappingPath,
    });
    
    try {
      await mapper.run();
      // Collect stats from the generated mapping file
      const stats = getMappingFileStats(outputMappingPath);
      generatedStats.push(stats);
    } catch (error) {
      console.error(`Error processing ${fileName}:`, error instanceof Error ? error.message : String(error));
      errorCount++;
    }
    
    console.log('');
  }
  
  if (errorCount > 0) {
    console.log(`⚠️  ${errorCount} file(s) failed to process`);
    console.log('');
  }
  
  return generatedStats;
}

/**
 * Displays a formatted summary table of generated mapping files
 */
function displayMappingSummary(stats: MappingFileStats[]): void {
  if (stats.length === 0) {
    console.log('No mapping files were generated.');
    return;
  }
  
  console.log('='.repeat(60));
  console.log('Generated Mapping Files');
  console.log('='.repeat(60));
  console.log('');
  
  // Find the longest filename for padding
  const maxFilenameLength = Math.max(...stats.map(s => s.filename.length));
  
  for (const stat of stats) {
    const paddedFilename = stat.filename.padEnd(maxFilenameLength + 2);
    console.log(`  ${paddedFilename}(${stat.practicesCount} practices → ${stat.standardsCount} standards)`);
  }
  
  // Calculate totals
  const totalPractices = stats.reduce((sum, s) => sum + s.practicesCount, 0);
  const totalStandards = stats.reduce((sum, s) => sum + s.standardsCount, 0);
  
  console.log('');
  console.log('-'.repeat(60));
  console.log(`Total: ${stats.length} file(s), ${totalPractices} practices, ${totalStandards} standards`);
  console.log('');
}

/**
 * Displays detailed review instructions for the user
 */
function displayReviewInstructions(): void {
  console.log('='.repeat(60));
  console.log('NEXT STEPS: Review the Generated Mapping Files');
  console.log('='.repeat(60));
  console.log('');
  console.log('Before running --import, you MUST review the .standards-mapping.yaml files.');
  console.log('');
  console.log('Open each file and:');
  console.log('');
  console.log('  1. RENAME STANDARDS if the names are unclear or too generic');
  console.log('     → Change "name: Code Quality" to something more specific');
  console.log('');
  console.log('  2. REDISTRIBUTE PRACTICES between standards if groupings');
  console.log('     don\'t make sense for your team');
  console.log('     → Move practices from one standard to another');
  console.log('');
  console.log('  3. CREATE NEW STANDARDS if you need finer granularity');
  console.log('     → Add a new "- name:" entry with its practices');
  console.log('');
  console.log('  4. REMOVE PRACTICES you don\'t want to import');
  console.log('     → Delete the practice line from the file');
  console.log('');
  console.log('Take your time to organize your standards in a way that');
  console.log('makes sense for your team.');
  console.log('');
  console.log('-'.repeat(60));
  console.log('When ready, run: bun run dev -- --import');
  console.log('='.repeat(60));
}

/**
 * Displays a formatted summary table of imported files
 */
function displayImportSummary(results: ImportFileResult[]): void {
  if (results.length === 0) {
    console.log('No files were imported.');
    return;
  }
  
  console.log('='.repeat(60));
  console.log('Import Summary');
  console.log('='.repeat(60));
  console.log('');
  
  // Find the longest filename for padding
  const maxFilenameLength = Math.max(...results.map(r => r.filename.length));
  
  for (const result of results) {
    const paddedFilename = result.filename.padEnd(maxFilenameLength + 2);
    const statsText = `(${result.standardsImported} standards, ${result.rulesImported} rules)`;
    
    let statusIcon: string;
    switch (result.status) {
      case 'success':
        statusIcon = '✅';
        break;
      case 'partial':
        statusIcon = '⚠️  partial';
        break;
      case 'failed':
        statusIcon = '❌ failed';
        break;
    }
    
    console.log(`  ${paddedFilename}${statsText} ${statusIcon}`);
  }
  
  // Calculate totals
  const totalStandardsImported = results.reduce((sum, r) => sum + r.standardsImported, 0);
  const totalRulesImported = results.reduce((sum, r) => sum + r.rulesImported, 0);
  const successfulFiles = results.filter(r => r.status === 'success').length;
  const partialFiles = results.filter(r => r.status === 'partial').length;
  const failedFiles = results.filter(r => r.status === 'failed').length;
  
  console.log('');
  console.log('-'.repeat(60));
  console.log(`Total: ${results.length} file(s), ${totalStandardsImported} standards, ${totalRulesImported} rules`);
  
  const statusParts: string[] = [];
  if (successfulFiles > 0) {
    statusParts.push(`${successfulFiles} succeeded`);
  }
  if (partialFiles > 0) {
    statusParts.push(`${partialFiles} partial`);
  }
  if (failedFiles > 0) {
    statusParts.push(`${failedFiles} failed`);
  }
  console.log(`Status: ${statusParts.join(' | ')}`);
  console.log('='.repeat(60));
}

/**
 * Runs the full mapping pipeline:
 * 1. Fetch spaces from Packmind API (--get-spaces)
 * 2. Process .jsonl files into YAML (--init)
 * 3. Generate standards mapping using LLM
 */
async function runMapCommand(): Promise<void> {
  // Validate LLM configuration early to fail fast with clear error messages
  validateLLMConfiguration();
  
  console.log('');
  console.log('='.repeat(60));
  console.log('Full Pipeline: get-spaces → init → map');
  console.log('='.repeat(60));
  console.log('');
  
  // Step 1: Fetch spaces from Packmind API
  console.log('='.repeat(60));
  console.log('Step 1: Fetching spaces from Packmind API');
  console.log('='.repeat(60));
  await runGetSpacesCommand();
  console.log('');
  
  // Step 2: Process .jsonl files into YAML
  console.log('='.repeat(60));
  console.log('Step 2: Processing .jsonl files');
  console.log('='.repeat(60));
  runMultiFileInit();
  console.log('');
  
  // Step 3: Generate standards mapping using LLM
  const mappingStats = await runLLMMappingStep();
  
  console.log('');
  console.log('='.repeat(60));
  console.log('Pipeline Complete!');
  console.log('='.repeat(60));
  console.log('');
  
  // Display summary table
  displayMappingSummary(mappingStats);
  
  // Display review instructions
  displayReviewInstructions();
}

/**
 * Runs the get-spaces command to fetch available spaces from Packmind API
 * @throws Error if API key is missing or API call fails
 */
async function runGetSpacesCommand(): Promise<void> {
  const apiKey = process.env['SOURCE_PACKMIND_API_KEY'];
  
  if (!apiKey) {
    throw new Error('SOURCE_PACKMIND_API_KEY environment variable is not set. Please set it in your .env file or environment.');
  }
  
  const outputPath = join(getResDir(), 'spaces.json');
  
  console.log('Fetching spaces from Packmind API...');
  
  const api = new PackmindAPI(apiKey);
  const spaces = await api.getSpaces();
  
  writeFileSync(outputPath, JSON.stringify(spaces, null, 2), 'utf-8');
  
  console.log(`Successfully fetched ${spaces.length} space(s).`);
  console.log(`Output written to: ${outputPath}`);
}

/**
 * Imports validation data to Packmind V3
 * @param filesToImport - Array of validation file stats to import
 * @param importOne - If true, only import the first standard from each file
 * @returns Array of import results for each file
 * @throws Error if API key is missing or all imports fail
 */
async function importValidationFiles(
  filesToImport: ValidationFileStats[],
  importOne: boolean = false
): Promise<ImportFileResult[]> {
  const apiKey = process.env['PACKMIND_V3_API_KEY']?.trim();

  if (!apiKey || apiKey.length === 0) {
    throw new Error('PACKMIND_V3_API_KEY environment variable is not set or is empty. Please set it in your .env file or environment.');
  }

  console.log('');
  console.log('='.repeat(60));
  console.log('Importing to Packmind V3');
  console.log('='.repeat(60));
  if (importOne) {
    console.log('Mode: First standard only (--one)');
  }
  console.log('');

  const connector = new PackmindV3Connector(apiKey);
  const results: ImportFileResult[] = [];

  for (const fileStats of filesToImport) {
    console.log('-'.repeat(60));
    console.log(`Importing: ${fileStats.filename}`);
    console.log('-'.repeat(60));

    try {
      // Load the validation file
      const data = JSON.parse(readFileSync(fileStats.path, 'utf-8')) as ValidationOutput;

      // Determine which standards to import
      let standardsToImport = data.standards;
      if (importOne && data.standards.length > 0) {
        const firstStandard = data.standards[0];
        if (firstStandard) {
          standardsToImport = [firstStandard];
          console.log(`  Mode: Importing first standard only`);
        }
      }

      console.log(`  Standards to import: ${standardsToImport.length}`);
      let totalRules = 0;
      for (const standard of standardsToImport) {
        totalRules += standard.rules?.length || 0;
      }
      console.log(`  Total rules: ${totalRules}`);
      console.log('');

      // Import each standard one by one
      let standardsImported = 0;
      let standardsFailed = 0;
      let rulesImported = 0;
      let rulesFailed = 0;

      for (let i = 0; i < standardsToImport.length; i++) {
        const standard = standardsToImport[i];
        if (!standard) continue;

        const progress = `[${i + 1}/${standardsToImport.length}]`;
        const rulesCount = standard.rules?.length || 0;

        console.log(`  ${progress} Importing: "${standard.name}" (${rulesCount} rules)`);

        try {
          const singleStandardData: ValidationOutput = { standards: [standard] };
          const result = await connector.importLegacy(singleStandardData);

          console.log(`  ${progress} ✅ Success`);
          if (result.message) {
            console.log(`  ${progress}    Message: ${result.message}`);
          }
          standardsImported++;
          rulesImported += rulesCount;
        } catch (standardError) {
          const errorMessage = standardError instanceof Error ? standardError.message : String(standardError);
          console.error(`  ${progress} ❌ Failed: ${errorMessage}`);
          standardsFailed++;
          rulesFailed += rulesCount;
        }
      }

      console.log('');
      console.log(`  File summary: ${standardsImported} succeeded, ${standardsFailed} failed`);

      // Determine file status
      let status: 'success' | 'partial' | 'failed';
      if (standardsFailed === 0) {
        status = 'success';
      } else if (standardsImported === 0) {
        status = 'failed';
      } else {
        status = 'partial';
      }

      results.push({
        filename: fileStats.filename,
        standardsImported,
        rulesImported,
        standardsFailed,
        rulesFailed,
        status,
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`  ❌ Error: ${errorMessage}`);
      
      results.push({
        filename: fileStats.filename,
        standardsImported: 0,
        rulesImported: 0,
        standardsFailed: fileStats.standardsCount,
        rulesFailed: fileStats.rulesCount,
        status: 'failed',
      });
    }

    console.log('');
  }

  // Check if all imports failed
  const allFailed = results.every(r => r.status === 'failed');
  if (allFailed && results.length > 0) {
    throw new Error('All imports failed');
  }

  return results;
}

/**
 * Generates .standards-validation.json files from .standards-mapping.yaml files
 * For each mapping file:
 * 1. Extracts slug from filename
 * 2. Loads practices from corresponding .jsonl file(s)
 * 3. Uses PracticeToStandardConvertor to convert practices to validation format
 * 4. Writes {slug}.standards-validation.json
 */
function generateValidationFiles(): void {
  const resDir = getResDir();
  const spacesPath = join(resDir, 'spaces.json');
  
  // Validate spaces.json exists
  if (!existsSync(spacesPath)) {
    throw new Error(`Spaces file not found: ${spacesPath}\nUse --get-spaces to fetch spaces from Packmind API first.`);
  }
  
  // Load spaces mapping and build reverse lookup (slug -> spaceId)
  const spacesMapping = loadSpacesMapping(spacesPath);
  const slugToSpaceId = buildSlugToSpaceIdMap(spacesMapping);
  
  // Discover all .jsonl files and load all practices
  const jsonlFiles = discoverJsonlFiles(resDir);
  
  if (jsonlFiles.length === 0) {
    throw new Error(`No .jsonl files found in: ${resDir}\nPlace your practices .jsonl files in the res/ folder.`);
  }
  
  console.log('='.repeat(60));
  console.log('Generating Validation JSON Files');
  console.log('='.repeat(60));
  console.log(`Found ${jsonlFiles.length} .jsonl file(s)`);
  
  // Load all practices from all .jsonl files
  const allPractices: ParsedPractice[] = [];
  for (const jsonlPath of jsonlFiles) {
    const practices = loadPracticesFromFile(jsonlPath);
    allPractices.push(...practices);
    console.log(`  Loaded ${practices.length} practice(s) from ${basename(jsonlPath)}`);
  }
  console.log(`Total practices loaded: ${allPractices.length}`);
  console.log('');
  
  // Discover all .standards-mapping.yaml files
  const mappingFiles = discoverStandardsMappingFiles(resDir);
  
  if (mappingFiles.length === 0) {
    throw new Error(`No .standards-mapping.yaml files found in: ${resDir}\nUse --map to generate standards mapping using LLM first.`);
  }
  
  console.log(`Found ${mappingFiles.length} standards mapping file(s)`);
  console.log('');
  
  let processedCount = 0;
  
  for (const mappingPath of mappingFiles) {
    const fileName = basename(mappingPath);
    const slug = extractSlugFromStandardsMappingFilename(fileName);
    
    if (!slug) {
      console.log(`⚠️  Skipping: Could not extract slug from ${fileName}`);
      continue;
    }
    
    // Get the space ID for this slug
    const spaceId = slugToSpaceId.get(slug);
    
    if (!spaceId) {
      console.log(`⚠️  Skipping ${slug}: No matching space found in spaces.json`);
      console.log(`   Available slugs: ${[...slugToSpaceId.keys()].join(', ')}`);
      continue;
    }
    
    // Filter practices belonging to this space
    const spacePractices = allPractices.filter(p => p.space === spaceId);
    
    if (spacePractices.length === 0) {
      console.log(`⚠️  Skipping ${slug}: No practices found for space ID ${spaceId}`);
      continue;
    }
    
    const outputPath = join(resDir, `${slug}.standards-validation.json`);
    
    console.log('-'.repeat(60));
    console.log(`Processing: ${slug}`);
    console.log('-'.repeat(60));
    console.log(`  Mapping: ${fileName}`);
    console.log(`  Space ID: ${spaceId}`);
    console.log(`  Practices found: ${spacePractices.length}`);
    
    // Create convertor and run conversion
    const convertor = new PracticeToStandardConvertor({
      spacesJsonPath: spacesPath,
      standardsMappingPath: mappingPath,
      contextLines: 2,
    });
    
    console.log('  Converting practices to standards...');
    const output = convertor.convert(spacePractices);
    
    // Write output
    writeFileSync(outputPath, JSON.stringify(output, null, 2), 'utf-8');
    
    // Calculate stats for this space
    let totalRules = 0;
    let totalPositiveExamples = 0;
    let totalNegativeExamples = 0;
    let rulesWithDetection = 0;
    
    for (const standard of output.standards) {
      totalRules += standard.rules.length;
      for (const rule of standard.rules) {
        totalPositiveExamples += rule.positiveExamples.length;
        totalNegativeExamples += rule.negativeExamples.length;
        if (rule.detectionProgram) {
          rulesWithDetection++;
        }
      }
    }
    
    console.log(`  Standards: ${output.standards.length}`);
    console.log(`  Rules: ${totalRules}`);
    console.log(`  Rules with detection: ${rulesWithDetection}`);
    console.log(`  Positive examples: ${totalPositiveExamples}`);
    console.log(`  Negative examples: ${totalNegativeExamples}`);
    console.log(`  → Output: ${basename(outputPath)}`);
    console.log('');
    
    processedCount++;
  }
  
  console.log('='.repeat(60));
  console.log(`Validation generation complete! Processed ${processedCount} file(s).`);
  console.log('='.repeat(60));
  console.log('');
}

/**
 * Runs the import command with interactive file selection
 * 1. Generates .standards-validation.json files from mapping files
 * 2. Discovers existing .standards-validation.json files in res/
 * 3. Prompts user to select which files to import
 * 4. Imports selected files to Packmind V3
 * @param importOne - If true, only import the first standard from each file
 * @throws Error if no validation files found or import fails
 */
async function runImportCommand(importOne: boolean = false): Promise<void> {
  const resDir = getResDir();

  // Step 1: Generate validation files from mapping files
  generateValidationFiles();

  // Step 2: Discover all .standards-validation.json files
  const validationFiles = discoverValidationFiles(resDir);

  if (validationFiles.length === 0) {
    throw new Error(`No .standards-validation.json files found in: ${resDir}\nMake sure you have .jsonl files and .standards-mapping.yaml files in the res/ folder.`);
  }

  // Get stats for each file
  const allStats: ValidationFileStats[] = [];
  for (const filePath of validationFiles) {
    try {
      const stats = getValidationFileStats(filePath);
      allStats.push(stats);
    } catch (error) {
      console.warn(`Warning: Could not read ${basename(filePath)}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  if (allStats.length === 0) {
    throw new Error('No valid validation files could be read.');
  }

  // Prompt user for file selection
  const selectedFiles = await promptFileSelection(allStats);

  if (selectedFiles.length === 0) {
    throw new Error('No files selected for import.');
  }

  // Import selected files
  const importResults = await importValidationFiles(selectedFiles, importOne);
  
  // Display summary
  displayImportSummary(importResults);
}

// ============================================================================
// Analyze Command
// ============================================================================

/**
 * Detection category for a practice
 */
type DetectionCategory = 
  | 'detection_success'
  | 'both_regex_semgrep'
  | 'regex_only'
  | 'semgrep_only'
  | 'none';

/**
 * Statistics for a single space
 */
interface SpaceAnalysisStats {
  spaceName: string;
  spaceId: string;
  totalPractices: number;
  detectionSuccess: number;
  bothRegexSemgrep: number;
  regexOnly: number;
  semgrepOnly: number;
  none: number;
  // Practice names by category (for detailed listing)
  practicesBothRegexSemgrep: string[];
  practicesRegexOnly: string[];
  practicesSemgrepOnly: string[];
}

/**
 * Checks if a practice has a successful detection program
 */
function hasDetectionSuccess(practice: ParsedPractice): boolean {
  if (practice.suggestionsDisabled) {
    return false;
  }
  if (!practice.toolings) {
    return false;
  }
  return practice.toolings.status === 'SUCCESS' && Boolean(practice.toolings.program);
}

/**
 * Checks if a practice has active regex patterns
 */
function hasActiveRegex(practice: ParsedPractice): boolean {
  return (practice.similarityFeatures?.regex?.length ?? 0) > 0;
}

/**
 * Checks if a practice has active semgrep patterns
 */
function hasActiveSemgrep(practice: ParsedPractice): boolean {
  return (practice.similarityFeatures?.semgrep?.length ?? 0) > 0;
}

/**
 * Categorizes a practice based on its detection capabilities
 */
function categorizePractice(practice: ParsedPractice): DetectionCategory {
  // Check detection program first (highest priority)
  if (hasDetectionSuccess(practice)) {
    return 'detection_success';
  }
  
  const hasRegex = hasActiveRegex(practice);
  const hasSemgrep = hasActiveSemgrep(practice);
  
  if (hasRegex && hasSemgrep) {
    return 'both_regex_semgrep';
  }
  
  if (hasRegex) {
    return 'regex_only';
  }
  
  if (hasSemgrep) {
    return 'semgrep_only';
  }
  
  return 'none';
}

/**
 * Formats a percentage with padding for alignment
 */
function formatPercentage(count: number, total: number): string {
  if (total === 0) return '  0.0%';
  const percentage = (count / total) * 100;
  const formatted = percentage.toFixed(1);
  return formatted.padStart(5) + '%';
}

/**
 * Formats a count with padding for alignment
 */
function formatCount(count: number, maxDigits: number): string {
  return count.toString().padStart(maxDigits);
}

/**
 * Displays a list of practice names with a label
 */
function displayPracticeNamesList(label: string, practices: string[]): void {
  if (practices.length === 0) return;
  
  console.log(`  ${label}:`);
  // Sort alphabetically and display
  const sorted = [...practices].sort((a, b) => a.localeCompare(b));
  for (const name of sorted) {
    console.log(`    - ${name}`);
  }
  console.log('');
}

/**
 * Displays analysis results for a single space
 */
function displaySpaceAnalysis(stats: SpaceAnalysisStats): void {
  const total = stats.totalPractices;
  const maxDigits = total.toString().length;
  
  console.log(`Space: ${stats.spaceName} (${total} practices)`);
  console.log('-'.repeat(60));
  console.log(`  Detection program (success):     ${formatCount(stats.detectionSuccess, maxDigits)} (${formatPercentage(stats.detectionSuccess, total)})`);
  console.log(`  Both regex + semgrep:            ${formatCount(stats.bothRegexSemgrep, maxDigits)} (${formatPercentage(stats.bothRegexSemgrep, total)})`);
  console.log(`  Regex only (no detection):       ${formatCount(stats.regexOnly, maxDigits)} (${formatPercentage(stats.regexOnly, total)})`);
  console.log(`  Semgrep only (no detection):     ${formatCount(stats.semgrepOnly, maxDigits)} (${formatPercentage(stats.semgrepOnly, total)})`);
  console.log(`  No detection configured:         ${formatCount(stats.none, maxDigits)} (${formatPercentage(stats.none, total)})`);
  console.log('');
  
  // Display practice names for regex/semgrep categories
  displayPracticeNamesList('Both regex + semgrep', stats.practicesBothRegexSemgrep);
  displayPracticeNamesList('Regex only', stats.practicesRegexOnly);
  displayPracticeNamesList('Semgrep only', stats.practicesSemgrepOnly);
}

/**
 * Runs the analyze command to display detection capabilities of practices
 */
function runAnalyzeCommand(): void {
  const resDir = getResDir();
  
  // Discover all .jsonl files in res/ (flat, not recursive)
  const jsonlFiles = discoverJsonlFiles(resDir);
  
  if (jsonlFiles.length === 0) {
    throw new Error('No .jsonl files found in res/ directory. Place your .jsonl files in the res/ folder and try again.');
  }
  
  console.log('');
  console.log('='.repeat(60));
  console.log('Analysis: Practice Detection Capabilities');
  console.log('='.repeat(60));
  console.log('');
  console.log(`Scanning ${jsonlFiles.length} .jsonl file(s) in res/`);
  console.log('');
  
  // Load all practices from all .jsonl files
  const allPractices: ParsedPractice[] = [];
  for (const jsonlPath of jsonlFiles) {
    const practices = loadPracticesFromFile(jsonlPath);
    allPractices.push(...practices);
  }
  
  if (allPractices.length === 0) {
    console.log('No practices found in .jsonl files.');
    return;
  }
  
  // Group practices by space ID
  const practicesBySpace = new Map<string, ParsedPractice[]>();
  for (const practice of allPractices) {
    const spaceId = practice.space;
    if (!practicesBySpace.has(spaceId)) {
      practicesBySpace.set(spaceId, []);
    }
    practicesBySpace.get(spaceId)!.push(practice);
  }
  
  // Try to load spaces.json for friendly names (optional)
  let spacesMapping = new Map<string, string>();
  const spacesJsonPath = join(resDir, 'spaces.json');
  try {
    spacesMapping = loadSpacesMapping(spacesJsonPath);
  } catch {
    // Ignore if spaces.json doesn't exist - we'll use space IDs
  }
  
  // Analyze each space
  const allStats: SpaceAnalysisStats[] = [];
  
  for (const [spaceId, practices] of practicesBySpace) {
    const spaceName = spacesMapping.get(spaceId) || `Space ${spaceId.slice(0, 8)}...`;
    
    const stats: SpaceAnalysisStats = {
      spaceName,
      spaceId,
      totalPractices: practices.length,
      detectionSuccess: 0,
      bothRegexSemgrep: 0,
      regexOnly: 0,
      semgrepOnly: 0,
      none: 0,
      practicesBothRegexSemgrep: [],
      practicesRegexOnly: [],
      practicesSemgrepOnly: [],
    };
    
    for (const practice of practices) {
      const category = categorizePractice(practice);
      switch (category) {
        case 'detection_success':
          stats.detectionSuccess++;
          break;
        case 'both_regex_semgrep':
          stats.bothRegexSemgrep++;
          stats.practicesBothRegexSemgrep.push(practice.name);
          break;
        case 'regex_only':
          stats.regexOnly++;
          stats.practicesRegexOnly.push(practice.name);
          break;
        case 'semgrep_only':
          stats.semgrepOnly++;
          stats.practicesSemgrepOnly.push(practice.name);
          break;
        case 'none':
          stats.none++;
          break;
      }
    }
    
    allStats.push(stats);
  }
  
  // Sort spaces by name for consistent output
  allStats.sort((a, b) => a.spaceName.localeCompare(b.spaceName));
  
  // Display results for each space
  for (const stats of allStats) {
    displaySpaceAnalysis(stats);
  }
  
  // Calculate and display totals
  const totalPractices = allStats.reduce((sum, s) => sum + s.totalPractices, 0);
  const totalDetectionSuccess = allStats.reduce((sum, s) => sum + s.detectionSuccess, 0);
  const totalBothRegexSemgrep = allStats.reduce((sum, s) => sum + s.bothRegexSemgrep, 0);
  const totalRegexOnly = allStats.reduce((sum, s) => sum + s.regexOnly, 0);
  const totalSemgrepOnly = allStats.reduce((sum, s) => sum + s.semgrepOnly, 0);
  const totalNone = allStats.reduce((sum, s) => sum + s.none, 0);
  
  console.log('='.repeat(60));
  console.log(`Total: ${allStats.length} space(s), ${totalPractices} practices analyzed`);
  console.log('='.repeat(60));
  
  const maxDigits = totalPractices.toString().length;
  console.log(`  Detection program (success):     ${formatCount(totalDetectionSuccess, maxDigits)} (${formatPercentage(totalDetectionSuccess, totalPractices)})`);
  console.log(`  Both regex + semgrep:            ${formatCount(totalBothRegexSemgrep, maxDigits)} (${formatPercentage(totalBothRegexSemgrep, totalPractices)})`);
  console.log(`  Regex only (no detection):       ${formatCount(totalRegexOnly, maxDigits)} (${formatPercentage(totalRegexOnly, totalPractices)})`);
  console.log(`  Semgrep only (no detection):     ${formatCount(totalSemgrepOnly, maxDigits)} (${formatPercentage(totalSemgrepOnly, totalPractices)})`);
  console.log(`  No detection configured:         ${formatCount(totalNone, maxDigits)} (${formatPercentage(totalNone, totalPractices)})`);
  console.log('='.repeat(60));
}

// ============================================================================
// Main Entry Point
// ============================================================================

/**
 * Main entry point - parses CLI arguments and runs the appropriate command
 */
async function main(): Promise<void> {
  try {
    const args = parseArgs(process.argv);
    
    switch (args.command) {
      case 'init':
        runInitCommand(args.inputFile, args.outputFile);
        break;
      case 'stats':
        runStatsCommand();
        break;
      case 'map':
        await runMapCommand();
        break;
      case 'get-spaces':
        await runGetSpacesCommand();
        break;
      case 'import':
        await runImportCommand(args.importOne || false);
        break;
      case 'analyze':
        runAnalyzeCommand();
        break;
    }
    
    // Exit successfully after command completion
    process.exit(0);
  } catch (error) {
    console.error('Error:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// Execute main function if this module is run directly
main().catch((error) => {
  console.error('Unhandled error:', error instanceof Error ? error.message : String(error));
  process.exit(1);
});

// Export all types for external use
export * from './types.js';

